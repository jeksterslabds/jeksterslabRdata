% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvn.R
\name{mvnramsigma2}
\alias{mvnramsigma2}
\title{Generate Multivariate Normal Data
\eqn{
  \mathbf{X}
  \sim
  \mathcal{N}_{k}
  \left(
    \boldsymbol{\mu},
    \boldsymbol{\Sigma}
  \right)
  %(\#eq:dist-X-mvn)
}
from the Reticular Action Model (RAM) Matrices.}
\usage{
mvnramsigma2(
  n,
  A,
  sigma2,
  F,
  I,
  M = NULL,
  mu = NULL,
  tol = 1e-06,
  empirical = FALSE,
  R = NULL,
  par = FALSE,
  ncores = NULL,
  mc = TRUE,
  lb = FALSE,
  cl_eval = FALSE,
  cl_export = FALSE,
  cl_expr,
  cl_vars
)
}
\arguments{
\item{n}{Integer.
Sample size.}

\item{A}{\eqn{\mathbf{A}} matrix.
Asymmetric paths (single-headed arrows),
such as regression coefficients and factor loadings.}

\item{sigma2}{Numeric vector.
Vector of variances \eqn{\sigma^2}.
\strong{The first element should be the variance of an exogenous variable}}

\item{F}{\eqn{\mathbf{F}} matrix.
Filter matrix
used to select the observed variables.}

\item{I}{\eqn{\mathbf{I}} matrix.
Identity matrix.}

\item{M}{Numeric vector.
Mean structure.
Vector of means and intercepts.}

\item{mu}{Numeric vector.
Location parameter mean vector \eqn{\boldsymbol{\mu}} of length \eqn{k}.}

\item{tol}{Numeric.
Tolerance (relative to largest variance)
for numerical lack of positive-definiteness in \code{Sigma}.}

\item{empirical}{Logical.
If \code{TRUE}, \code{mu} and \code{Sigma} specify the empirical
not population mean and covariance matrix.}

\item{R}{Integer.
Number of Monte Carlo replications.
If \code{R} is not provided,
the function produces a single random data set.
If \code{R} is an integer greater than 1,
(e.g., \code{R = 10}),
the function produces
multiple random data sets
stored in each element of a list of length \code{R}.
\code{par} and all succeeding arguments are only relevant
when \code{R > 1}.}

\item{par}{Logical.
If \code{TRUE}, use multiple cores.
If \code{FALSE}, use \code{\link[=lapply]{lapply()}}.}

\item{ncores}{Integer.
Number of cores to use if \code{par = TRUE}.
If unspecified, defaults to \code{detectCores() - 1}.}

\item{mc}{Logical.
If \code{TRUE}, use \code{\link[parallel:mclapply]{parallel::mclapply()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}} or \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
Ignored if \code{par = FALSE}.}

\item{lb}{Logical.
If \code{TRUE} use \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}}.
Ignored if \code{par = FALSE} and \code{mc = TRUE}.}

\item{cl_eval}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}} using \code{cl_expr}.
Ignored if \code{mc = TRUE}.}

\item{cl_export}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterExport()}} using \code{cl_vars}.
Ignored if \code{mc = TRUE}.}

\item{cl_expr}{Expression.
Expression passed to \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}}
Ignored if \code{mc = TRUE}.}

\item{cl_vars}{Character vector.
Names of objects to pass to \code{\link[parallel:clusterApply]{parallel::clusterExport()}}
Ignored if \code{mc = TRUE}.}
}
\value{
If \code{R = NULL} or \code{R = 1},
returns an \eqn{n \times k} multivariate normal data matrix generated
using the provided or derived mean vector \code{mu}
\eqn{\left( \boldsymbol{\mu} \right)}
and the derived variance-covariance matrix \code{Sigma}
\eqn{\left( \boldsymbol{\Sigma} \right)}.
If \code{R} is an integer greater than 1,
(e.g., \code{R = 10})
returns a list of length \code{R} of
\eqn{n \times k} multivariate normal data matrices generated
using the provided or derived mean vector \code{mu}
and the derived variance-covariance matrix \code{Sigma}.
}
\description{
The \eqn{\mathbf{S}} matrix
is derived from a vector of variances.
}
\examples{
# One-factor CFA model--------------------------------------------------------
A <- matrix(data = 0, ncol = 6, nrow = 6)
for (i in 2:6) {
  A[i, 1] <- 0.5
}
sigma2 <- c(1, 1, 1, 1, 1, 1)
F <- I <- diag(nrow(A))
F <- diag(nrow(A) - 1)
F <- cbind(0, F)
X <- mvnramsigma2(
  n = 100,
  A = A,
  sigma2 = sigma2,
  F = F,
  I = I,
  empirical = TRUE
)
str(X, list.len = 6)
cov(X)
}
\seealso{
Other multivariate data functions: 
\code{\link{mvnram}()},
\code{\link{mvn}()}
}
\author{
Ivan Jacob Agaloos Pesigan
}
\concept{multivariate data functions}
\keyword{multivariate}
\keyword{normal}
