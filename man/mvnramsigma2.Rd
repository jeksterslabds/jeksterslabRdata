% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvn.R
\name{mvnramsigma2}
\alias{mvnramsigma2}
\title{Generate Multivariate Normal Data
\eqn{
    \mathbf{X} \sim \mathcal{N}_{k}
    \left( \boldsymbol{\mu}, \boldsymbol{\Sigma} \right)
    %(\#eq:dist-X-mvn)
  }
from the Reticular Action Model  Matrices
\eqn{\mathrm{A}}, \eqn{\mathrm{F}}, \eqn{\mathrm{I}},
and the vector of variable variances \eqn{\sigma^2}}
\usage{
mvnramsigma2(
  n,
  mu = NULL,
  M = NULL,
  A,
  sigma2,
  F,
  I,
  tol = 1e-06,
  empirical = FALSE,
  df = FALSE,
  varnames = NULL,
  R = NULL,
  par = FALSE,
  ncores = NULL,
  mc = TRUE,
  lb = FALSE,
  cl_eval = FALSE,
  cl_export = FALSE,
  cl_expr,
  cl_vars
)
}
\arguments{
\item{n}{Integer.
Sample size.}

\item{mu}{Numeric vector.
Location parameter mean vector \eqn{\boldsymbol{\mu}} of length \eqn{k}.}

\item{M}{Numeric vector.
Mean structure.
Vector of means and intercepts.}

\item{A}{\eqn{\mathbf{A}} matrix.
Asymmetric paths (single-headed arrows),
such as regression coefficients and factor loadings.}

\item{sigma2}{Numeric vector.
Vector of variances \eqn{\sigma^2}.
\strong{The first element should be the variance of an exogenous variable}}

\item{F}{\eqn{\mathbf{F}} matrix.
Filter matrix
used to select the observed variables.}

\item{I}{\eqn{\mathbf{I}} matrix.
Identity matrix.}

\item{tol}{Numeric.
Tolerance (relative to largest variance)
for numerical lack of positive-definiteness in \code{Sigma}.}

\item{empirical}{Logical.
If \code{TRUE}, \code{mu} and \code{Sigma} specify the empirical,
not population. mean and covariance matrix.}

\item{df}{Logical.
If \code{TRUE}, the function returns a data frame.
If \code{FALSE}, the function returns a matrix.}

\item{varnames}{Character string.
Optional column names with the same length as \code{mu}.}

\item{R}{Integer.
Number of Monte Carlo replications. If \code{R} is not provided,
the function produces a single random data set.
If \code{R} is an integer greater than 1, (e.g., \code{R = 10}),
the function produces multiple random data sets
stored in each element of a list of length \code{R}.
\code{par} and all succeeding arguments are only relevant when \code{R > 1}.}

\item{par}{Logical.
If \code{TRUE}, use multiple cores.
If \code{FALSE}, use \code{\link[=lapply]{lapply()}}.}

\item{ncores}{Integer.
Number of cores to use if \code{par = TRUE}.
If unspecified, defaults to \code{detectCores() - 1}.}

\item{mc}{Logical.
If \code{TRUE}, use \code{\link[parallel:mclapply]{parallel::mclapply()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}} or \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
Ignored if \code{par = FALSE}.}

\item{lb}{Logical.
If \code{TRUE} use \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}}.
Ignored if \code{par = FALSE} and \code{mc = TRUE}.}

\item{cl_eval}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}} using \code{cl_expr}.
Ignored if \code{mc = TRUE}.}

\item{cl_export}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterExport()}} using \code{cl_vars}.
Ignored if \code{mc = TRUE}.}

\item{cl_expr}{Expression.
Expression passed to \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}}
Ignored if \code{mc = TRUE}.}

\item{cl_vars}{Character vector.
Names of objects to pass to \code{\link[parallel:clusterApply]{parallel::clusterExport()}}
Ignored if \code{mc = TRUE}.}
}
\value{
If \code{R = NULL} or \code{R = 1}, returns an \eqn{n \times k}
multivariate normal data matrix or data frame .
If \code{R} is an integer greater than 1, (e.g., \code{R = 10})
returns a list of length \code{R} of \eqn{n \times k}
multivariate normal data matrix or data frame.
}
\description{
Generates an \eqn{n \times k} multivariate data matrix
or a list of \eqn{n \times k} multivariate data matrices of length \code{R}
from the multivariate normal distribution
\deqn{
    \mathbf{X} \sim \mathcal{N}_{k}
    \left( \boldsymbol{\mu}, \boldsymbol{\Sigma} \right) .
    %(\#eq:dist-X-mvn)
  }
The model-implied matrices used to generate data
is derived from the Reticular Action Model (RAM) Matrices.
}
\details{
The \eqn{\mathbf{S}} matrix is derived
from a vector of variances sigma2 \eqn{\left( \sigma^2 \right)}
and the proceeds to generating data using the \code{\link[=mvnram]{mvnram()}} function.
\strong{The first element in sigma2 should be the variance of an exogenous variable.}
}
\examples{
mu <- c(100, 100, 100)
A <- matrix(
  data = c(0, sqrt(0.26), 0, 0, 0, sqrt(0.26), 0, 0, 0),
  ncol = 3
)
sigma2 <- c(225, 225, 225)
F <- I <- diag(3)
X <- mvnramsigma2(n = 100, mu = mu, A = A, sigma2 = sigma2, F = F, I = I)
Xstar <- mvnramsigma2(n = 100, mu = mu, A = A, sigma2 = sigma2, F = F, I = I, R = 100)
}
\seealso{
Other multivariate data functions: 
\code{\link{mvnram}()},
\code{\link{mvn}()}
}
\author{
Ivan Jacob Agaloos Pesigan
}
\concept{multivariate data functions}
\keyword{multivariate}
\keyword{normal}
