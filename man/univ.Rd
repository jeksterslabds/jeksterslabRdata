% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/univ.R
\name{univ}
\alias{univ}
\title{Generate Univariate Data}
\usage{
univ(
  n,
  rFUN = rnorm,
  ...,
  R = NULL,
  par = FALSE,
  ncores = NULL,
  mc = TRUE,
  lb = FALSE,
  cl_eval = FALSE,
  cl_export = FALSE,
  cl_expr,
  cl_vars,
  rbind = NULL
)
}
\arguments{
\item{n}{Integer.
Sample size.}

\item{rFUN}{Function.
Data generating function to generate univariate data.}

\item{...}{Arguments to pass to \code{rFUN}.}

\item{R}{Integer.
Number of Monte Carlo replications. If \code{R} is not provided,
the function produces a single random data set.
If \code{R} is an integer greater than 1, (e.g., \code{R = 10}),
the function produces multiple random data sets
stored in each element of a list of length \code{R}.
\code{par} and all succeeding arguments are only relevant when \code{R > 1}.}

\item{par}{Logical.
If \code{TRUE}, use multiple cores.
If \code{FALSE}, use \code{\link[=lapply]{lapply()}}.}

\item{ncores}{Integer.
Number of cores to use if \code{par = TRUE}.
If unspecified, defaults to \code{detectCores() - 1}.}

\item{mc}{Logical.
If \code{TRUE}, use \code{\link[parallel:mclapply]{parallel::mclapply()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}} or \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
Ignored if \code{par = FALSE}.}

\item{lb}{Logical.
If \code{TRUE} use \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}}.
Ignored if \code{par = FALSE} and \code{mc = TRUE}.}

\item{cl_eval}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}} using \code{cl_expr}.
Ignored if \code{mc = TRUE}.}

\item{cl_export}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterExport()}} using \code{cl_vars}.
Ignored if \code{mc = TRUE}.}

\item{cl_expr}{Expression.
Expression passed to \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}}
Ignored if \code{mc = TRUE}.}

\item{cl_vars}{Character vector.
Names of objects to pass to \code{\link[parallel:clusterApply]{parallel::clusterExport()}}
Ignored if \code{mc = TRUE}.}

\item{rbind}{NULL or logical.
If \code{rbind = NULL},
returns the list produced.
If \code{TRUE}, uses \code{\link[=rbind]{rbind()}}
to bind the rows of the list produced.
If \code{FALSE}, uses \code{\link[=cbind]{cbind()}}
to bind the columns of the list produced.
Test that each element of the output list
has the appropriate dimensions for binding
before using this option.}
}
\value{
If \code{R = NULL} or \code{R = 1},
returns an \eqn{ n \times 1 } univariate data vector generated
using \code{rFUN} and parameters passed to \code{...}.
If \code{R} is an integer greater than 1, (e.g., \code{R = 10})
returns a list of length \code{R} of \eqn{ n \times 1 } univariate data vector
generated using \code{rFUN} and parameters passed to \code{...}.
}
\description{
Generates an \eqn{n \times 1} univariate data vector
or a list of \eqn{n \times 1} univariate data vectors of length \code{R}.
The default data generating function
is the normal distribution
\deqn{
    X \sim \mathcal{N} \left( \mu, \sigma^2 \right) .
    %(\#eq:dist-X-norm)
  }
}
\details{
The univariate distribution and parameters used
in the data generating process can be specified using \code{rFUN} and \code{...}.

Options for explicit parallelism are provided when \code{R > 1}
especially when \code{R} is large. See \code{par} and suceeding arguments.
}
\examples{
x <- univ(n = 1000, rFUN = rnorm, mean = 100, sd = sqrt(225))
xstar <- univ(n = 1000, rFUN = rnorm, mean = 100, sd = sqrt(225), R = 1000)
}
\author{
Ivan Jacob Agaloos Pesigan
}
\concept{univariate data functions}
\keyword{univariate}
