% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit.R
\name{fit}
\alias{fit}
\title{Fit a Function to Each Element of a List of Data}
\usage{
fit(
  Xstar,
  fitFUN,
  ...,
  par = FALSE,
  ncores = NULL,
  mc = TRUE,
  lb = FALSE,
  cl_eval = FALSE,
  cl_export = FALSE,
  cl_expr,
  cl_vars,
  rbind = TRUE
)
}
\arguments{
\item{Xstar}{List.
A list of length \code{R} with a data set of length \code{n} in each element of the list.}

\item{fitFUN}{Function.
Fit function to be applied to each element of \code{Xstar}.}

\item{...}{Argument to pass to \code{fitFUN}.}

\item{par}{Logical.
If \code{TRUE}, use multiple cores.
If \code{FALSE}, use \code{\link[=lapply]{lapply()}}.}

\item{ncores}{Integer.
Number of cores to use if \code{par = TRUE}.
If unspecified, defaults to \code{detectCores() - 1}.}

\item{mc}{Logical.
If \code{TRUE}, use \code{\link[parallel:mclapply]{parallel::mclapply()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}} or \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
Ignored if \code{par = FALSE}.}

\item{lb}{Logical.
If \code{TRUE} use \code{\link[parallel:clusterApply]{parallel::parLapplyLB()}}.
If \code{FALSE}, use \code{\link[parallel:clusterApply]{parallel::parLapply()}}.
Ignored if \code{par = FALSE} and \code{mc = TRUE}.}

\item{cl_eval}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}} using \code{cl_expr}.
Ignored if \code{mc = TRUE}.}

\item{cl_export}{Logical.
Execute \code{\link[parallel:clusterApply]{parallel::clusterExport()}} using \code{cl_vars}.
Ignored if \code{mc = TRUE}.}

\item{cl_expr}{Expression.
Expression passed to \code{\link[parallel:clusterApply]{parallel::clusterEvalQ()}}
Ignored if \code{mc = TRUE}.}

\item{cl_vars}{Character vector.
Names of objects to pass to \code{\link[parallel:clusterApply]{parallel::clusterExport()}}
Ignored if \code{mc = TRUE}.}

\item{rbind}{NULL or logical.
If \code{rbind = NULL},
returns the list produced.
If \code{TRUE}, uses \code{\link[=rbind]{rbind()}}
to bind the rows of the list produced.
If \code{FALSE}, uses \code{\link[=cbind]{cbind()}}
to bind the columns of the list produced.
Test that each element of the output list
has the appropriate dimensions for binding
before using this option.}
}
\value{
Returns a list of parameter estimates.
}
\description{
Fits a function to each element of a list of data.
}
\details{
The first argument of \code{fitFUN} should be \code{data}
The output of \code{fitFUN} should be a vector.

Options for explicit parallelism are provided.
See \code{par} and suceeding arguments.
}
\examples{
xstar <- univ(n = 100, rFUN = rnorm, mean = 100, sd = sqrt(225), R = 100)
thetahatstar <- fit(Xstar = xstar, fitFUN = mean, rbind = TRUE)
mean(thetahatstar)
Xstar <- mvn(
  n = 100,
  Sigma = matrix(c(1, .5, .5, 1), nrow = 2),
  R = 100
)
foo <- function(X) {
  as.vector(cov(X))
}
thetahatstar <- fit(Xstar = Xstar, fitFUN = foo, rbind = TRUE)
thetahatstar <- thetahatstar[, 2]
mean(thetahatstar)
}
\author{
Ivan Jacob Agaloos Pesigan
}
\concept{model fit functions}
\keyword{fit}
\keyword{model}
